package handlersv3

// FUTURE - only implement if needed this is for - information about mountable macOS disk images.

// import (
// 	bh "github.com/AustralianCyberSecurityCentre/azul-plugin-virustotal.git/virustotal/vtmap/basehandlerv3"
// )

// var vtToAzFeatDmgInfo = []bh.VtPathToAzFeature{
//     bh.NewVtPathToAzFeat("blkx", bh.VtTypeListOfDict, "blkx", bh.dont-map, "dmgInfo - each item on the list represents a BLKX block in the DMG image and contains the following fields:"),
//     bh.NewVtPathToAzFeat("blkx.attributes", bh.VtTypeString, "blkx_attributes", bh.AzFTString, "dmgInfo - in hex format."),
//     bh.NewVtPathToAzFeat("blkx.name", bh.VtTypeString, "blkx_name", bh.AzFTString, "dmgInfo - block name."),
//     bh.NewVtPathToAzFeat("data_fork_length", bh.VtTypeInteger, "data_fork_length", bh.AzFTInteger, "dmgInfo - size of data fork."),
//     bh.NewVtPathToAzFeat("data_fork_offset", bh.VtTypeInteger, "data_fork_offset", bh.AzFTInteger, "dmgInfo - data fork offset (usually 0)."),
//     bh.NewVtPathToAzFeat("dmg_version", bh.VtTypeInteger, "dmg_version", bh.AzFTInteger, "dmgInfo - DMG file version."),
//     bh.NewVtPathToAzFeat("gtp", bh.VtTypeDict, "gtp", bh.dont-map, "dmgInfo - information about GPT header. Contains the following subfields:"),
//     bh.NewVtPathToAzFeat("gtp.alternate_lba", bh.VtTypeInteger, "gtp_alternate_lba", bh.AzFTInteger, "dmgInfo - the LBA of the alternate GPT header."),
//     bh.NewVtPathToAzFeat("gtp.disk_uuid", bh.VtTypeString, "gtp_disk_uuid", bh.AzFTString, "dmgInfo - GUID of the disk."),
//     bh.NewVtPathToAzFeat("gtp.entries_crc32", bh.VtTypeInteger, "gtp_entries_crc32", bh.AzFTInteger, "dmgInfo - CRC32 of the Partition Entry array."),
//     bh.NewVtPathToAzFeat("gtp.entries_lba", bh.VtTypeInteger, "gtp_entries_lba", bh.AzFTInteger, "dmgInfo - starting LBA of the GUID Parition Entry array."),
//     bh.NewVtPathToAzFeat("gtp.first_usable_lba", bh.VtTypeInteger, "gtp_first_usable_lba", bh.AzFTInteger, "dmgInfo - the first usable block that can be contained in a GPT entry."),
//     bh.NewVtPathToAzFeat("gtp.header_crc32", bh.VtTypeInteger, "gtp_header_crc32", bh.AzFTInteger, "dmgInfo - CRC32 checksum of the GPT header."),
//     bh.NewVtPathToAzFeat("gtp.last_usable_lba", bh.VtTypeInteger, "gtp_last_usable_lba", bh.AzFTInteger, "dmgInfo - the last usable block that can be contained in a GPT entry."),
//     bh.NewVtPathToAzFeat("gtp.my_lba", bh.VtTypeInteger, "gtp_my_lba", bh.AzFTInteger, "dmgInfo - the LBA containing this header."),
//     bh.NewVtPathToAzFeat("gtp.number_of_entries", bh.VtTypeInteger, "gtp_number_of_entries", bh.AzFTInteger, "dmgInfo - number of Parition Entries."),
//     bh.NewVtPathToAzFeat("gtp.partitions", bh.VtTypeListOfDict, "gtp_partitions", bh.dont-map, "dmgInfo - contains details about each partition. Every entry contains the following subfields:"),
//     bh.NewVtPathToAzFeat("gtp.partitions.attrs_flags", bh.VtTypeInteger, "gtp_partitions_attrs_flags", bh.AzFTInteger, "dmgInfo - attributes"),
//     bh.NewVtPathToAzFeat("gtp.partitions.ending_lba", bh.VtTypeInteger, "gtp_partitions_ending_lba", bh.AzFTInteger, "dmgInfo - ending LBA."),
//     bh.NewVtPathToAzFeat("gtp.partitions.name", bh.VtTypeString, "gtp_partitions_name", bh.AzFTString, "dmgInfo - partition name."),
//     bh.NewVtPathToAzFeat("gtp.partitions.starting_lba", bh.VtTypeInteger, "gtp_partitions_starting_lba", bh.AzFTInteger, "dmgInfo - starting LBA."),
//     bh.NewVtPathToAzFeat("gtp.partitions.type_guid", bh.VtTypeString, "gtp_partitions_type_guid", bh.AzFTString, "dmgInfo - partition Type GUID (zero means unused entry)."),
//     bh.NewVtPathToAzFeat("gtp.partitions.unique_guid", bh.VtTypeString, "gtp_partitions_unique_guid", bh.AzFTString, "dmgInfo - unique Partition GUID."),
//     bh.NewVtPathToAzFeat("gtp.revision", bh.VtTypeString, "gtp_revision", bh.AzFTString, "dmgInfo - GPT Revision."),
//     bh.NewVtPathToAzFeat("gtp.signature", bh.VtTypeString, "gtp_signature", bh.AzFTString, "dmgInfo - signature, can be identified by 8 bytes magic 'EFI PART' (45h 46h 49h 20h 50h 41h 52h 54h)."),
//     bh.NewVtPathToAzFeat("gtp.size", bh.VtTypeInteger, "gtp_size", bh.AzFTInteger, "dmgInfo - header size."),
//     bh.NewVtPathToAzFeat("gtp.size_of_entry", bh.VtTypeInteger, "gtp_size_of_entry", bh.AzFTInteger, "dmgInfo - size (in bytes) of each entry in the Parition Entry array - must be a multiple of 8."),
//     bh.NewVtPathToAzFeat("hfs", bh.VtTypeDict, "hfs", bh.dont-map, "dmgInfo - information about HFS elements. Depending on each case, different fields may appear or not."),
//     bh.NewVtPathToAzFeat("hfs.info_plist", bh.VtTypeDict, "hfs_info_plist", bh.dont-map, "dmgInfo - block's plist (Info.plist file) content. Keys and values are strings."),
//     bh.NewVtPathToAzFeat("hfs.main_executable", bh.VtTypeDict, "hfs_main_executable", bh.dont-map, "dmgInfo - block's main executable. Contains the following subfields:"),
//     bh.NewVtPathToAzFeat("hfs.main_executable.id", bh.VtTypeString, "hfs_main_executable_id", bh.AzFTString, "dmgInfo - identifier."),
//     bh.NewVtPathToAzFeat("hfs.main_executable.path", bh.VtTypeString, "hfs_main_executable_path", bh.AzFTString, "dmgInfo - path inside the package."),
//     bh.NewVtPathToAzFeat("hfs.main_executable.sha256", bh.VtTypeString, "hfs_main_executable_sha256", bh.AzFTString, "dmgInfo - content hash."),
//     bh.NewVtPathToAzFeat("hfs.main_executable.size", bh.VtTypeInteger, "hfs_main_executable_size", bh.AzFTInteger, "dmgInfo - file size in bytes."),
//     bh.NewVtPathToAzFeat("hfs.num_files", bh.VtTypeInteger, "hfs_num_files", bh.AzFTInteger, "dmgInfo - number of files."),
//     bh.NewVtPathToAzFeat("hfs.unreadable_files", bh.VtTypeInteger, "hfs_unreadable_files", bh.AzFTInteger, "dmgInfo - number of unreadable files."),
//     bh.NewVtPathToAzFeat("hfs.timeout", bh.VtTypeBool, "hfs_timeout", bh.AzFTString, "dmgInfo - whether the block's processing took too long or not."),
//     bh.NewVtPathToAzFeat("iso", bh.VtTypeDict, "iso", bh.dont-map, "dmgInfo - information about ISO elements. Depending on each case, different fields may appear or not."),
//     bh.NewVtPathToAzFeat("iso.info_plist", bh.VtTypeDict, "iso_info_plist", bh.dont-map, "dmgInfo - block's plist (Info.plist file) content. Keys and values are strings."),
//     bh.NewVtPathToAzFeat("iso.main_executable", bh.VtTypeDict, "iso_main_executable", bh.dont-map, "dmgInfo - block's main executable. Contains the following subfields:"),
//     bh.NewVtPathToAzFeat("iso.main_executable.id", bh.VtTypeString, "iso_main_executable_id", bh.AzFTString, "dmgInfo - identifier."),
//     bh.NewVtPathToAzFeat("iso.main_executable.path", bh.VtTypeString, "iso_main_executable_path", bh.AzFTString, "dmgInfo - path inside the package."),
//     bh.NewVtPathToAzFeat("iso.main_executable.sha256", bh.VtTypeString, "iso_main_executable_sha256", bh.AzFTString, "dmgInfo - content hash."),
//     bh.NewVtPathToAzFeat("iso.main_executable.size", bh.VtTypeInteger, "iso_main_executable_size", bh.AzFTInteger, "dmgInfo - file size in bytes."),
//     bh.NewVtPathToAzFeat("iso.num_files", bh.VtTypeInteger, "iso_num_files", bh.AzFTInteger, "dmgInfo - number of files."),
//     bh.NewVtPathToAzFeat("iso.unreadable_files", bh.VtTypeInteger, "iso_unreadable_files", bh.AzFTInteger, "dmgInfo - number of unreadable files."),
//     bh.NewVtPathToAzFeat("iso.timeout", bh.VtTypeBool, "iso_timeout", bh.AzFTString, "dmgInfo - whether the block's processing took too long or not."),
//     bh.NewVtPathToAzFeat("iso.volume_data", bh.VtTypeDict, "iso_volume_data", bh.dont-map, "dmgInfo - ISO volume data. Check isoimage_info output to know its structure."),
//     bh.NewVtPathToAzFeat("plst", bh.VtTypeListOfDict, "plst", bh.dont-map, "dmgInfo - contains configuration information for the application, such as its bundle ID, version number, and display name. Each entry contains two keys:"),
//     bh.NewVtPathToAzFeat("plst.attributes", bh.VtTypeString, "plst_attributes", bh.AzFTString, "dmgInfo - in hex format."),
//     bh.NewVtPathToAzFeat("plst.name", bh.VtTypeString, "plst_name", bh.AzFTString, "dmgInfo - attribute name."),
//     bh.NewVtPathToAzFeat("plst_context", bh.VtTypeListOfStrings, "plst_context", bh.AzFTString, "dmgInfo - contains extracted interesting strings from a list, such as SLAs."),
//     bh.NewVtPathToAzFeat("plst_keys", bh.VtTypeListOfStrings, "plst_keys", bh.AzFTString, "dmgInfo - keys of the plst entry."),
//     bh.NewVtPathToAzFeat("running_data_fork_offset", bh.VtTypeInteger, "running_data_fork_offset", bh.AzFTInteger, "dmgInfo - specifies where the running data fork starts, usually 0."),
//     bh.NewVtPathToAzFeat("resourcefork_keys", bh.VtTypeListOfStrings, "resourcefork_keys", bh.AzFTString, "dmgInfo - keys found in the resource fork."),
//     bh.NewVtPathToAzFeat("rsrc_fork_length", bh.VtTypeInteger, "rsrc_fork_length", bh.AzFTInteger, "dmgInfo - resource fork length."),
//     bh.NewVtPathToAzFeat("rsrc_fork_offset", bh.VtTypeInteger, "rsrc_fork_offset", bh.AzFTInteger, "dmgInfo - resource fork offset."),
//     bh.NewVtPathToAzFeat("xml_lenght", bh.VtTypeInteger, "xml_lenght", bh.AzFTInteger, "dmgInfo - lenght of property list in DMG."),
//     bh.NewVtPathToAzFeat("xml_offset", bh.VtTypeInteger, "xml_offset", bh.AzFTInteger, "dmgInfo - offset of property list in DMG."),
// }

// var dmgInfo = bh.NewHandlerV3(vtToAzFeatDmgInfo)
